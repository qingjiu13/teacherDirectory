{"version":3,"file":"JWT.js","sources":["store/user/JWT.js"],"sourcesContent":["/**\r\n * JWT相关工具函数\r\n * @module store/user/JWT\r\n */\r\n\r\n// 导入路由管理器\r\nimport { Navigator } from '@/router/Router.js';\r\n\r\n/**\r\n * 创建JWT令牌\r\n * @param {string} userId - 用户ID\r\n * @param {string} [secret='yanshilu-jwt-secret'] - 加密密钥\r\n * @param {Object} [additionalData={}] - 额外的数据\r\n * @returns {string} 生成的JWT令牌\r\n */\r\nexport const createToken = (userId, secret = 'yanshilu-jwt-secret', additionalData = {}) => {\r\n  // 构建JWT的payload部分\r\n  const payload = {\r\n    userId: userId,\r\n    ...additionalData,\r\n    iat: Math.floor(Date.now() / 1000), // 令牌签发时间\r\n    exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7 // 7天过期\r\n  };\r\n\r\n  // Base64编码header\r\n  const header = {\r\n    alg: 'HS256',\r\n    typ: 'JWT'\r\n  };\r\n  const base64Header = btoa(JSON.stringify(header));\r\n\r\n  // Base64编码payload\r\n  const base64Payload = btoa(JSON.stringify(payload));\r\n\r\n  // 创建签名 (在前端我们使用简化版本，真实签名应在后端完成)\r\n  const signature = createSignature(`${base64Header}.${base64Payload}`, secret);\r\n\r\n  // 返回完整的JWT\r\n  return `${base64Header}.${base64Payload}.${signature}`;\r\n};\r\n\r\n/**\r\n * 创建签名（简化版，生产环境应使用专业库）\r\n * @param {string} data - 要签名的数据\r\n * @param {string} secret - 签名密钥\r\n * @returns {string} 签名结果\r\n */\r\nconst createSignature = (data, secret) => {\r\n  // 注意：这是签名的简化实现，仅用于演示\r\n  // 生产环境中应使用crypto-js或其他安全库进行真实HMAC-SHA256签名\r\n  let hash = 0;\r\n  for (let i = 0; i < data.length; i++) {\r\n    const char = data.charCodeAt(i);\r\n    hash = ((hash << 5) - hash) + char;\r\n    hash |= 0; // 转换为32位整数\r\n  }\r\n  return btoa(hash + secret);\r\n};\r\n\r\n/**\r\n * 验证JWT令牌\r\n * @param {string} token - JWT令牌\r\n * @param {string} [secret='yanshilu-jwt-secret'] - 加密密钥\r\n * @returns {boolean} 令牌是否有效\r\n */\r\nexport const verifyToken = (token, secret = 'yanshilu-jwt-secret') => {\r\n  try {\r\n    // 分解JWT各部分\r\n    const [headerBase64, payloadBase64, signature] = token.split('.');\r\n    \r\n    // 验证签名\r\n    const expectedSignature = createSignature(`${headerBase64}.${payloadBase64}`, secret);\r\n    if (signature !== expectedSignature) {\r\n      return false;\r\n    }\r\n    \r\n    // 解析payload\r\n    const payload = JSON.parse(atob(payloadBase64));\r\n    \r\n    // 检查是否过期\r\n    const currentTime = Math.floor(Date.now() / 1000);\r\n    if (payload.exp && payload.exp < currentTime) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('JWT验证失败:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * 解析JWT令牌获取用户ID\r\n * @param {string} token - JWT令牌\r\n * @returns {string|null} 用户ID，无效令牌返回null\r\n */\r\nexport const getUserIdFromToken = (token) => {\r\n  try {\r\n    const [, payloadBase64] = token.split('.');\r\n    const payload = JSON.parse(atob(payloadBase64));\r\n    return payload.userId || null;\r\n  } catch (error) {\r\n    console.error('解析JWT令牌失败:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * 解析JWT令牌获取完整载荷\r\n * @param {string} token - JWT令牌\r\n * @returns {Object|null} 载荷对象，无效令牌返回null\r\n */\r\nexport const getPayloadFromToken = (token) => {\r\n  try {\r\n    const [, payloadBase64] = token.split('.');\r\n    return JSON.parse(atob(payloadBase64));\r\n  } catch (error) {\r\n    console.error('解析JWT载荷失败:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * 获取当前用户令牌\r\n * @returns {string|null} 用户令牌，未登录返回null\r\n */\r\nexport const getCurrentToken = () => {\r\n  return uni.getStorageSync('user-token') || null;\r\n};\r\n\r\n/**\r\n * 获取当前用户ID\r\n * @returns {string|null} 用户ID，未登录返回null\r\n */\r\nexport const getCurrentUserId = () => {\r\n  const token = getCurrentToken();\r\n  return token ? getUserIdFromToken(token) : null;\r\n};\r\n\r\n/**\r\n * 基于JWT令牌的统一API请求工具\r\n * @param {string} url - 请求URL\r\n * @param {string} [method='GET'] - 请求方法\r\n * @param {Object} [data={}] - 请求数据\r\n * @param {Object} [options={}] - 额外选项\r\n * @param {boolean} [options.autoAddUserId=true] - 是否自动添加用户ID\r\n * @param {boolean} [options.requireAuth=true] - 是否要求认证\r\n * @param {boolean} [options.showError=true] - 是否显示错误提示\r\n * @param {Object} [options.customHeader={}] - 自定义请求头\r\n * @returns {Promise<Object>} 请求结果Promise\r\n */\r\nexport const apiRequest = (url, method = 'GET', data = {}, options = {}) => {\r\n  const defaultOptions = {\r\n    autoAddUserId: true,\r\n    requireAuth: true,\r\n    showError: true,\r\n    customHeader: {}\r\n  };\r\n  \r\n  const finalOptions = { ...defaultOptions, ...options };\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    // 获取令牌\r\n    const token = getCurrentToken();\r\n    \r\n    // 如果需要认证但没有令牌\r\n    if (finalOptions.requireAuth && (!token || !verifyToken(token))) {\r\n      const error = {\r\n        success: false,\r\n        error: {\r\n          code: 401,\r\n          message: '未登录或认证已过期，请重新登录'\r\n        }\r\n      };\r\n      \r\n      if (finalOptions.showError) {\r\n        uni.showToast({\r\n          title: error.error.message,\r\n          icon: 'none',\r\n          duration: 2000\r\n        });\r\n      }\r\n      \r\n      reject(error);\r\n      return;\r\n    }\r\n    \r\n    // 准备请求数据，如果需要则自动添加用户ID\r\n    let requestData = { ...data };\r\n    \r\n    if (finalOptions.autoAddUserId && token) {\r\n      const userId = getUserIdFromToken(token);\r\n      if (userId) {\r\n        requestData = method.toUpperCase() === 'GET' \r\n          ? { ...requestData, userId } \r\n          : { ...requestData, userId };\r\n      }\r\n    }\r\n    \r\n    // 准备请求头\r\n    const headers = {\r\n      'Content-Type': 'application/json',\r\n      ...finalOptions.customHeader\r\n    };\r\n    \r\n    // 如果有令牌则添加到请求头\r\n    if (token) {\r\n      headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    \r\n    // 发送请求\r\n    uni.request({\r\n      url,\r\n      method: method.toUpperCase(),\r\n      data: requestData,\r\n      header: headers,\r\n      success: (res) => {\r\n        // 请求成功但业务逻辑错误\r\n        if (res.statusCode === 200 && res.data && res.data.code === 200) {\r\n          resolve({\r\n            success: true,\r\n            data: res.data.data\r\n          });\r\n        } else if (res.statusCode === 401 || res.statusCode === 403) {\r\n          // 认证失败，清除令牌\r\n          uni.removeStorageSync('user-token');\r\n          uni.removeStorageSync('userId');\r\n          \r\n          const error = {\r\n            success: false,\r\n            error: {\r\n              statusCode: res.statusCode,\r\n              message: res.data?.msg || (res.statusCode === 401 ? '认证已过期，请重新登录' : '无权访问')\r\n            }\r\n          };\r\n          \r\n          if (finalOptions.showError) {\r\n            uni.showToast({\r\n              title: error.error.message,\r\n              icon: 'none',\r\n              duration: 2000\r\n            });\r\n            \r\n            // 如果认证失败，可以跳转到登录页\r\n            setTimeout(() => {\r\n              Navigator.toLogin();\r\n            }, 2000);\r\n          }\r\n          \r\n          reject(error);\r\n        } else {\r\n          // 其他业务逻辑错误\r\n          const error = {\r\n            success: false,\r\n            error: {\r\n              statusCode: res.statusCode,\r\n              message: res.data?.msg || '请求失败'\r\n            }\r\n          };\r\n          \r\n          if (finalOptions.showError) {\r\n            uni.showToast({\r\n              title: error.error.message,\r\n              icon: 'none',\r\n              duration: 2000\r\n            });\r\n          }\r\n          \r\n          reject(error);\r\n        }\r\n      },\r\n      fail: (err) => {\r\n        // 网络请求失败\r\n        const error = {\r\n          success: false,\r\n          error: {\r\n            message: err.errMsg || '网络请求失败'\r\n          }\r\n        };\r\n        \r\n        if (finalOptions.showError) {\r\n          uni.showToast({\r\n            title: error.error.message,\r\n            icon: 'none',\r\n            duration: 2000\r\n          });\r\n        }\r\n        \r\n        reject(error);\r\n      }\r\n    });\r\n  });\r\n};\r\n"],"names":["createSignature","data","secret","hash","i","char","verifyToken","token","headerBase64","payloadBase64","signature","expectedSignature","payload","currentTime","error","uni","getUserIdFromToken","getCurrentToken","apiRequest","url","method","options","finalOptions","resolve","reject","requestData","userId","headers","res","_a","Navigator","_b","err"],"mappings":"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"}