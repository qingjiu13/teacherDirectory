{"version":3,"file":"useLottieReady.js","sources":["components/loading-animation/useLottieReady.js"],"sourcesContent":["// useLottieReady.js\r\nimport { ref, onMounted, watch, reactive } from 'vue'\r\n\r\n/**\r\n * 动画资源缓存\r\n * @type {Map<string, Object>}\r\n */\r\nconst animationCache = new Map()\r\n\r\n/**\r\n * 正在加载中的动画请求，避免重复请求\r\n * @type {Map<string, Promise<Object>>}\r\n */\r\nconst pendingRequests = new Map()\r\n\r\n/**\r\n * 全局动画加载状态\r\n * @type {Object}\r\n */\r\nconst globalAnimationState = reactive({\r\n  /**\r\n   * 所有已加载的动画源\r\n   * @type {Set<string>}\r\n   */\r\n  loadedSources: new Set(),\r\n  \r\n  /**\r\n   * 所有已缓存的动画源\r\n   * @type {Set<string>}\r\n   */\r\n  cachedSources: new Set(),\r\n  \r\n  /**\r\n   * 当前正在加载的动画源\r\n   * @type {Set<string>}\r\n   */\r\n  loadingSources: new Set(),\r\n  \r\n  /**\r\n   * 加载失败的动画源\r\n   * @type {Set<string>}\r\n   */\r\n  failedSources: new Set()\r\n})\r\n\r\n/**\r\n * Lottie动画加载状态钩子\r\n * @param {import('vue').Ref} cLottieRef - Lottie组件引用\r\n * @returns {{isReady: import('vue').Ref<boolean>, isLoading: import('vue').Ref<boolean>, preloadAnimation: Function, getFromCache: Function, clearCache: Function, cacheStats: Function, getCacheStatus: Function, globalState: Object}} 动画加载状态和缓存操作方法\r\n */\r\nexport function useLottieReady(cLottieRef) {\r\n  const isReady = ref(false)\r\n  const isLoading = ref(false)\r\n  const currentSrc = ref('')\r\n\r\n  /**\r\n   * 绑定Lottie数据加载完成事件\r\n   */\r\n  const attachHandler = () => {\r\n    if (!cLottieRef.value) return\r\n    \r\n    // 兼容新版API\r\n    if (typeof cLottieRef.value.on === 'function') {\r\n      cLottieRef.value.on('dataReady', () => {\r\n        isReady.value = true\r\n        isLoading.value = false\r\n        if (currentSrc.value) {\r\n          globalAnimationState.loadedSources.add(currentSrc.value)\r\n          globalAnimationState.loadingSources.delete(currentSrc.value)\r\n        }\r\n        console.log('Lottie 动画已加载完成')\r\n      })\r\n      \r\n      // 添加加载失败事件监听\r\n      cLottieRef.value.on('error', (err) => {\r\n        isLoading.value = false\r\n        if (currentSrc.value) {\r\n          globalAnimationState.failedSources.add(currentSrc.value)\r\n          globalAnimationState.loadingSources.delete(currentSrc.value)\r\n        }\r\n        console.error('Lottie 动画加载失败:', err)\r\n      })\r\n    }\r\n    // 兼容旧版API\r\n    else if (typeof cLottieRef.value.$on === 'function') {\r\n      cLottieRef.value.$on('dataReady', () => {\r\n        isReady.value = true\r\n        isLoading.value = false\r\n        if (currentSrc.value) {\r\n          globalAnimationState.loadedSources.add(currentSrc.value)\r\n          globalAnimationState.loadingSources.delete(currentSrc.value)\r\n        }\r\n        console.log('Lottie 动画已加载完成')\r\n      })\r\n      \r\n      // 添加加载失败事件监听\r\n      cLottieRef.value.$on('error', (err) => {\r\n        isLoading.value = false\r\n        if (currentSrc.value) {\r\n          globalAnimationState.failedSources.add(currentSrc.value)\r\n          globalAnimationState.loadingSources.delete(currentSrc.value)\r\n        }\r\n        console.error('Lottie 动画加载失败:', err)\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 预加载动画资源并缓存\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {Promise<Object>} 已加载的动画数据\r\n   */\r\n  const preloadAnimation = (src) => {\r\n    return new Promise((resolve, reject) => {\r\n      // 检查缓存中是否已有此动画\r\n      if (animationCache.has(src)) {\r\n        console.log('从缓存中获取动画:', src)\r\n        globalAnimationState.loadingSources.delete(src)\r\n        globalAnimationState.loadedSources.add(src)\r\n        resolve(animationCache.get(src))\r\n        return\r\n      }\r\n      \r\n      // 检查是否已经有相同URL的请求正在进行中\r\n      if (pendingRequests.has(src)) {\r\n        console.log('已有相同动画正在加载中，复用请求:', src)\r\n        return pendingRequests.get(src).then(resolve).catch(reject)\r\n      }\r\n      \r\n      isLoading.value = true\r\n      currentSrc.value = src\r\n      globalAnimationState.loadingSources.add(src)\r\n      \r\n      console.log('开始加载动画:', src)\r\n      \r\n      // 创建加载动画的Promise\r\n      const loadPromise = new Promise((innerResolve, innerReject) => {\r\n        // 使用fetch预加载JSON\r\n        fetch(src)\r\n          .then(response => {\r\n            if (!response.ok) {\r\n              throw new Error(`网络请求失败: ${response.status} ${response.statusText}`)\r\n            }\r\n            return response.json()\r\n          })\r\n          .then(data => {\r\n            // 将数据存入缓存\r\n            animationCache.set(src, data)\r\n            globalAnimationState.cachedSources.add(src)\r\n            globalAnimationState.loadedSources.add(src)\r\n            globalAnimationState.loadingSources.delete(src)\r\n            console.log('动画已缓存:', src)\r\n            isLoading.value = false\r\n            \r\n            // 从pendingRequests中移除\r\n            pendingRequests.delete(src)\r\n            \r\n            innerResolve(data)\r\n          })\r\n          .catch(error => {\r\n            isLoading.value = false\r\n            globalAnimationState.failedSources.add(src)\r\n            globalAnimationState.loadingSources.delete(src)\r\n            console.error('预加载动画失败:', error)\r\n            \r\n            // 从pendingRequests中移除\r\n            pendingRequests.delete(src)\r\n            \r\n            innerReject(error)\r\n          })\r\n      })\r\n      \r\n      // 将请求保存到正在进行的请求映射中\r\n      pendingRequests.set(src, loadPromise)\r\n      \r\n      // 将结果传递给原始Promise\r\n      loadPromise.then(resolve).catch(reject)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 从缓存中获取动画数据\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {Object|null} 缓存的动画数据或null\r\n   */\r\n  const getFromCache = (src) => {\r\n    if (animationCache.has(src)) {\r\n      return animationCache.get(src)\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * 检查是否有指定动画源的请求正在进行中\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {boolean} 是否正在加载\r\n   */\r\n  const isPending = (src) => {\r\n    return pendingRequests.has(src)\r\n  }\r\n\r\n  /**\r\n   * 清除指定的缓存\r\n   * @param {string} src - 要清除的动画资源地址，如果不提供则清除所有\r\n   */\r\n  const clearCache = (src) => {\r\n    if (src) {\r\n      animationCache.delete(src)\r\n      globalAnimationState.cachedSources.delete(src)\r\n      console.log('已清除动画缓存:', src)\r\n    } else {\r\n      animationCache.clear()\r\n      globalAnimationState.cachedSources.clear()\r\n      console.log('已清除所有动画缓存')\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object} 缓存统计信息\r\n   */\r\n  const cacheStats = () => {\r\n    return {\r\n      totalCached: animationCache.size,\r\n      cachedSources: Array.from(animationCache.keys()),\r\n      totalLoaded: globalAnimationState.loadedSources.size,\r\n      loadedSources: Array.from(globalAnimationState.loadedSources),\r\n      totalLoading: globalAnimationState.loadingSources.size,\r\n      loadingSources: Array.from(globalAnimationState.loadingSources),\r\n      totalFailed: globalAnimationState.failedSources.size,\r\n      failedSources: Array.from(globalAnimationState.failedSources),\r\n      pendingRequests: pendingRequests.size,\r\n      pendingSources: Array.from(pendingRequests.keys())\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 获取特定动画源的缓存状态\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {Object} 动画缓存状态\r\n   */\r\n  const getCacheStatus = (src) => {\r\n    return {\r\n      isCached: animationCache.has(src),\r\n      isLoaded: globalAnimationState.loadedSources.has(src),\r\n      isLoading: globalAnimationState.loadingSources.has(src) || pendingRequests.has(src),\r\n      hasFailed: globalAnimationState.failedSources.has(src),\r\n      isPending: pendingRequests.has(src)\r\n    }\r\n  }\r\n\r\n  onMounted(() => {\r\n    attachHandler()\r\n  })\r\n\r\n  // 防止加载太快没绑定到，watch 观察也处理一下\r\n  watch(cLottieRef, (newVal) => {\r\n    if (newVal) {\r\n      attachHandler()\r\n    }\r\n  })\r\n\r\n  return {\r\n    isReady,\r\n    isLoading,\r\n    preloadAnimation,\r\n    getFromCache,\r\n    clearCache,\r\n    cacheStats,\r\n    getCacheStatus,\r\n    isPending,\r\n    globalState: globalAnimationState\r\n  }\r\n}\r\n\r\n/**\r\n * 批量预加载多个动画\r\n * @param {Array<string>} sources - 动画资源地址数组\r\n * @param {Function} progressCallback - 进度回调函数\r\n * @returns {Promise<Object>} 加载结果\r\n */\r\nexport function preloadAnimations(sources, progressCallback) {\r\n  let completed = 0;\r\n  const total = sources.length;\r\n  const results = {};\r\n\r\n  return Promise.all(\r\n    sources.map(src => \r\n      fetch(src)\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            throw new Error(`网络请求失败: ${response.status} ${response.statusText}`);\r\n          }\r\n          return response.json();\r\n        })\r\n        .then(data => {\r\n          // 将数据存入缓存\r\n          animationCache.set(src, data);\r\n          globalAnimationState.cachedSources.add(src);\r\n          globalAnimationState.loadedSources.add(src);\r\n          \r\n          // 进度回调\r\n          completed++;\r\n          if (typeof progressCallback === 'function') {\r\n            progressCallback({\r\n              src,\r\n              completed,\r\n              total,\r\n              progress: (completed / total) * 100,\r\n              success: true,\r\n              data\r\n            });\r\n          }\r\n          \r\n          results[src] = { success: true, data };\r\n          return { src, success: true };\r\n        })\r\n        .catch(error => {\r\n          globalAnimationState.failedSources.add(src);\r\n          \r\n          // 进度回调\r\n          completed++;\r\n          if (typeof progressCallback === 'function') {\r\n            progressCallback({\r\n              src,\r\n              completed,\r\n              total,\r\n              progress: (completed / total) * 100,\r\n              success: false,\r\n              error\r\n            });\r\n          }\r\n          \r\n          results[src] = { success: false, error };\r\n          return { src, success: false, error };\r\n        })\r\n    )\r\n  ).then(() => {\r\n    return {\r\n      totalSuccess: Object.values(results).filter(r => r.success).length,\r\n      totalFailed: Object.values(results).filter(r => !r.success).length,\r\n      results\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * 获取全局动画状态（组件外部使用）\r\n * @returns {Object} 全局动画状态\r\n */\r\nexport function useGlobalAnimationState() {\r\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object} 缓存统计信息\r\n   */\r\n  const getGlobalStats = () => {\r\n    return {\r\n      totalCached: animationCache.size,\r\n      cachedSources: Array.from(animationCache.keys()),\r\n      totalLoaded: globalAnimationState.loadedSources.size,\r\n      loadedSources: Array.from(globalAnimationState.loadedSources),\r\n      totalLoading: globalAnimationState.loadingSources.size,\r\n      loadingSources: Array.from(globalAnimationState.loadingSources),\r\n      totalFailed: globalAnimationState.failedSources.size,\r\n      failedSources: Array.from(globalAnimationState.failedSources),\r\n      pendingRequests: pendingRequests.size,\r\n      pendingSources: Array.from(pendingRequests.keys())\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 检查动画加载是否全部完成\r\n   * @returns {boolean} 是否所有动画都已加载完成\r\n   */\r\n  const isAllAnimationsLoaded = () => {\r\n    return globalAnimationState.loadingSources.size === 0 && pendingRequests.size === 0\r\n  }\r\n  \r\n  /**\r\n   * 从缓存中获取动画\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {Object|null} 缓存的动画数据或null\r\n   */\r\n  const getAnimationFromCache = (src) => {\r\n    return animationCache.get(src) || null\r\n  }\r\n  \r\n  /**\r\n   * 预加载单个动画\r\n   * @param {string} src - 动画资源地址\r\n   * @returns {Promise<Object>} 已加载的动画数据\r\n   */\r\n  const preloadSingleAnimation = (src) => {\r\n    // 检查缓存\r\n    if (animationCache.has(src)) {\r\n      return Promise.resolve(animationCache.get(src))\r\n    }\r\n    \r\n    // 检查已存在的请求\r\n    if (pendingRequests.has(src)) {\r\n      return pendingRequests.get(src)\r\n    }\r\n    \r\n    // 创建新请求\r\n    globalAnimationState.loadingSources.add(src)\r\n    \r\n    const loadPromise = fetch(src)\r\n      .then(response => {\r\n        if (!response.ok) {\r\n          throw new Error(`网络请求失败: ${response.status} ${response.statusText}`)\r\n        }\r\n        return response.json()\r\n      })\r\n      .then(data => {\r\n        // 将数据存入缓存\r\n        animationCache.set(src, data)\r\n        globalAnimationState.cachedSources.add(src)\r\n        globalAnimationState.loadedSources.add(src)\r\n        globalAnimationState.loadingSources.delete(src)\r\n        \r\n        // 完成后从pendingRequests中移除\r\n        pendingRequests.delete(src)\r\n        \r\n        return data\r\n      })\r\n      .catch(error => {\r\n        globalAnimationState.failedSources.add(src)\r\n        globalAnimationState.loadingSources.delete(src)\r\n        \r\n        // 错误后从pendingRequests中移除\r\n        pendingRequests.delete(src)\r\n        \r\n        throw error\r\n      })\r\n    \r\n    // 存储到待处理请求中\r\n    pendingRequests.set(src, loadPromise)\r\n    \r\n    return loadPromise\r\n  }\r\n  \r\n  return {\r\n    globalState: globalAnimationState,\r\n    getGlobalStats,\r\n    isAllAnimationsLoaded,\r\n    getAnimationFromCache,\r\n    preloadAnimation: preloadSingleAnimation,\r\n    preloadAnimations\r\n  }\r\n}\r\n"],"names":["reactive","ref","uni","onMounted","watch"],"mappings":"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"}