{"version":3,"file":"API.js","sources":["api/API.js"],"sourcesContent":["/**\r\n * @description API接口封装模块\r\n */\r\n\r\n// API基础配置\r\nconst API_CONFIG = {\r\n    BASE_URL: 'https://api.yourserviceurl.com', // 修改为您的实际API地址\r\n    TIMEOUT: 30000, // 默认超时时间（30秒）\r\n    RETRY_COUNT: 2, // 失败重试次数\r\n    VERSION: 'v1' // API版本\r\n};\r\n\r\n// API路径常量\r\nconst API_PATHS = {\r\n    CHAT: '/chat',\r\n    USER: '/user'\r\n};\r\n\r\n// 错误码和消息映射\r\nconst ERROR_MESSAGES = {\r\n    NETWORK_ERROR: '网络连接失败，请检查您的网络设置',\r\n    TIMEOUT_ERROR: '请求超时，请稍后再试',\r\n    SERVER_ERROR: '服务器错误，请稍后再试',\r\n    AUTH_ERROR: '身份验证失败，请重新登录',\r\n    INVALID_PARAM: '参数错误',\r\n    RATE_LIMIT: '请求过于频繁，请稍后再试',\r\n    UNKNOWN_ERROR: '未知错误，请稍后再试',\r\n    ABORT_ERROR: '请求已被取消'\r\n};\r\n\r\n/**\r\n * @description 创建请求头\r\n * @param {Object} customHeaders - 自定义请求头\r\n * @returns {Object} 完整的请求头对象\r\n */\r\nconst createHeaders = (customHeaders = {}) => {\r\n    const headers = {\r\n        'Content-Type': 'application/json',\r\n        'X-Client-Version': API_CONFIG.VERSION,\r\n        ...customHeaders\r\n    };\r\n\r\n    // 从存储中获取token（如果有）\r\n    try {\r\n        const token = uni.getStorageSync('token');\r\n        if (token) {\r\n            headers['Authorization'] = `Bearer ${token}`;\r\n        }\r\n    } catch (e) {\r\n        console.error('获取token失败:', e);\r\n    }\r\n\r\n    return headers;\r\n};\r\n\r\n/**\r\n * @description 创建完整的API URL\r\n * @param {String} path - API路径\r\n * @returns {String} 完整的API URL\r\n */\r\nconst createApiUrl = (path) => {\r\n    return `${API_CONFIG.BASE_URL}${path}`;\r\n};\r\n\r\n/**\r\n * @description 处理响应错误\r\n * @param {Object} error - 错误对象\r\n * @returns {Error} 格式化的错误对象\r\n */\r\nconst handleResponseError = (error) => {\r\n    let errorMessage = ERROR_MESSAGES.UNKNOWN_ERROR;\r\n    \r\n    if (error.name === 'AbortError') {\r\n        return new Error(ERROR_MESSAGES.ABORT_ERROR);\r\n    }\r\n    \r\n    if (typeof error === 'string') {\r\n        return new Error(error);\r\n    }\r\n    \r\n    if (error.statusCode) {\r\n        // 处理HTTP状态码错误\r\n        if (error.statusCode === 401 || error.statusCode === 403) {\r\n            errorMessage = ERROR_MESSAGES.AUTH_ERROR;\r\n        } else if (error.statusCode === 404) {\r\n            errorMessage = '请求的资源不存在';\r\n        } else if (error.statusCode === 429) {\r\n            errorMessage = ERROR_MESSAGES.RATE_LIMIT;\r\n        } else if (error.statusCode >= 500) {\r\n            errorMessage = ERROR_MESSAGES.SERVER_ERROR;\r\n        }\r\n    } else if (error.errMsg) {\r\n        // 处理uni请求错误\r\n        if (error.errMsg.includes('timeout')) {\r\n            errorMessage = ERROR_MESSAGES.TIMEOUT_ERROR;\r\n        } else if (error.errMsg.includes('fail')) {\r\n            errorMessage = ERROR_MESSAGES.NETWORK_ERROR;\r\n        }\r\n    }\r\n    \r\n    // 包含原始错误信息以便调试\r\n    const enhancedError = new Error(errorMessage);\r\n    enhancedError.originalError = error;\r\n    \r\n    return enhancedError;\r\n};\r\n\r\n/**\r\n * @description 中断请求\r\n * @param {AbortController} controller - 请求控制器\r\n */\r\nexport const abortRequest = (controller) => {\r\n    if (controller) {\r\n        try {\r\n            controller.abort();\r\n        } catch (e) {\r\n            console.error('中断请求失败:', e);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @description 发送聊天消息到AI并处理流式响应\r\n * @param {Object} params - 请求参数，包含用户消息和上下文\r\n * @param {Function} onChunk - 处理流式数据块的回调\r\n * @param {AbortSignal} signal - 用于取消请求的信号\r\n * @returns {Promise<void>} Promise对象\r\n */\r\nexport const sendChatMessage = async (params, onChunk, signal) => {\r\n    const url = createApiUrl(API_PATHS.CHAT);\r\n    const headers = createHeaders({\r\n        'Accept': 'text/event-stream',\r\n        'X-Stream-Mode': 'true'\r\n    });\r\n    \r\n    try {\r\n        // 准备请求数据\r\n        const requestData = {\r\n            message: params.message,\r\n            mode: params.context?.mode || 'general',\r\n            userInfo: {\r\n                school: params.context?.userSchool,\r\n                major: params.context?.userMajor\r\n            },\r\n            history: params.history || []\r\n        };\r\n        \r\n        // 检查环境 - 微信小程序不支持 fetch 和 ReadableStream API\r\n        // #ifdef MP-WEIXIN\r\n        // 微信小程序环境 - 使用模拟流式响应方式\r\n        return await handleWeixinChatRequest(url, headers, requestData, onChunk);\r\n        // #endif\r\n        \r\n        // #ifndef MP-WEIXIN\r\n        // 非微信小程序环境 - 使用标准 fetch API\r\n        const requestOptions = {\r\n            method: 'POST',\r\n            headers: headers,\r\n            body: JSON.stringify(requestData)\r\n        };\r\n        \r\n        // 仅在支持 AbortController 的环境中添加信号\r\n        if (signal) {\r\n            requestOptions.signal = signal;\r\n        }\r\n        \r\n        // 创建Fetch请求\r\n        const response = await fetch(url, requestOptions);\r\n        \r\n        // 检查响应状态\r\n        if (!response.ok) {\r\n            let errorText = await response.text();\r\n            try {\r\n                const errorJson = JSON.parse(errorText);\r\n                throw { \r\n                    statusCode: response.status, \r\n                    message: errorJson.message || `HTTP错误 ${response.status}` \r\n                };\r\n            } catch (e) {\r\n                throw { \r\n                    statusCode: response.status, \r\n                    message: `HTTP错误 ${response.status}` \r\n                };\r\n            }\r\n        }\r\n        \r\n        // 获取响应流\r\n        const reader = response.body.getReader();\r\n        const decoder = new TextDecoder();\r\n        \r\n        // 处理流式响应\r\n        while (true) {\r\n            const { done, value } = await reader.read();\r\n            \r\n            if (done) {\r\n                break;\r\n            }\r\n            \r\n            // 解码数据\r\n            const chunk = decoder.decode(value, { stream: true });\r\n            \r\n            // 处理解码后的块数据\r\n            processStreamChunk(chunk, onChunk);\r\n        }\r\n        // #endif\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        throw handleResponseError(error);\r\n    }\r\n};\r\n\r\n/**\r\n * @description 微信小程序环境下的聊天请求处理（模拟流式响应）\r\n * @param {String} url - 请求URL\r\n * @param {Object} headers - 请求头\r\n * @param {Object} requestData - 请求数据\r\n * @param {Function} onChunk - 数据块处理回调\r\n * @returns {Promise<Boolean>} 请求结果\r\n * @private\r\n */\r\nconst handleWeixinChatRequest = async (url, headers, requestData, onChunk) => {\r\n    return new Promise((resolve, reject) => {\r\n        // 微信小程序环境使用uni.request\r\n        uni.request({\r\n            url: url,\r\n            method: 'POST',\r\n            header: headers,\r\n            data: requestData,\r\n            timeout: API_CONFIG.TIMEOUT,\r\n            success: (res) => {\r\n                if (res.statusCode !== 200) {\r\n                    return reject({\r\n                        statusCode: res.statusCode,\r\n                        message: `HTTP错误 ${res.statusCode}`\r\n                    });\r\n                }\r\n                \r\n                // 模拟流式响应，将返回的数据按字符分割\r\n                const simulateStreamResponse = (text) => {\r\n                    if (!text) return resolve(true);\r\n                    \r\n                    // 每次发送的字符数\r\n                    const chunkSize = 5;\r\n                    // 间隔时间(毫秒)\r\n                    const interval = 50;\r\n                    \r\n                    let index = 0;\r\n                    \r\n                    const sendChunk = () => {\r\n                        if (index >= text.length) {\r\n                            return resolve(true);\r\n                        }\r\n                        \r\n                        const end = Math.min(index + chunkSize, text.length);\r\n                        const chunk = text.substring(index, end);\r\n                        \r\n                        onChunk(chunk);\r\n                        index = end;\r\n                        \r\n                        setTimeout(sendChunk, interval);\r\n                    };\r\n                    \r\n                    sendChunk();\r\n                };\r\n                \r\n                // 处理响应数据\r\n                if (typeof res.data === 'string') {\r\n                    simulateStreamResponse(res.data);\r\n                } else if (res.data && res.data.content) {\r\n                    simulateStreamResponse(res.data.content);\r\n                } else {\r\n                    // 如果没有有效数据，直接返回成功\r\n                    resolve(true);\r\n                }\r\n            },\r\n            fail: (err) => {\r\n                reject(err);\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * @description 处理流式响应的数据块\r\n * @param {String} chunk - 数据块\r\n * @param {Function} onChunk - 处理回调\r\n */\r\nconst processStreamChunk = (chunk, onChunk) => {\r\n    if (!chunk) return;\r\n    \r\n    // 根据服务器的流格式进行处理\r\n    // 示例：假设服务器以 \"data: \" 前缀发送数据\r\n    const lines = chunk.split('\\n');\r\n    \r\n    for (const line of lines) {\r\n        if (line.startsWith('data: ')) {\r\n            const data = line.substring(6); // 移除 \"data: \" 前缀\r\n            \r\n            if (data === '[DONE]') {\r\n                // 流结束标记\r\n                return;\r\n            }\r\n            \r\n            try {\r\n                // 尝试解析JSON数据\r\n                const parsedData = JSON.parse(data);\r\n                if (parsedData.content) {\r\n                    onChunk(parsedData.content);\r\n                }\r\n            } catch (e) {\r\n                // 如果不是JSON，则直接传递数据\r\n                onChunk(data);\r\n            }\r\n        } else if (line.trim() !== '') {\r\n            // 处理其他非空行，可能是纯文本内容\r\n            onChunk(line);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @description 获取用户信息\r\n * @returns {Promise<Object>} 用户信息\r\n */\r\nexport const getUserInfo = async () => {\r\n    const url = createApiUrl(API_PATHS.USER);\r\n    const headers = createHeaders();\r\n    \r\n    try {\r\n        const response = await uni.request({\r\n            url: url,\r\n            method: 'GET',\r\n            header: headers,\r\n            timeout: API_CONFIG.TIMEOUT\r\n        });\r\n        \r\n        if (response.statusCode !== 200) {\r\n            throw { statusCode: response.statusCode };\r\n        }\r\n        \r\n        return response.data;\r\n    } catch (error) {\r\n        throw handleResponseError(error);\r\n    }\r\n};\r\n\r\n// 导出API配置，便于其他模块使用\r\nexport const apiConfig = API_CONFIG;\r\n"],"names":["uni"],"mappings":"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"}